---
title: Sideloaded Verification Keys
sidebar_label: Sideloading
---

In the article on [recursion](/docs/advanced-concepts/recursion.mdx), we showed how o1js can be used to
write constraint systems that verify other constraint systems.  Those examples always assumed that the
prover has compiled an instance of the other `ZkProgram`.  We can, in fact, go even more general than that.
With sideloading, we can verify any proof, given that its shape (public inputs and outputs) are known at
compile time, and the verification key is available at runtime.

## Multiple Hash Example

Let's say we have an application with multiple hashing algorithms in use.  We want to write a simple Zk
Program to verify that a user knows the preimage of a hash, but we want to support any of our 
algorithms.  Let's solve this by writing a specific program for each algorithm, and a wrapper program
that verifies any of them.

### Setup

First, let's set up a bytes32 class and some different hash function proofs.  Note that all proofs must
have the same shape.

```ts file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_setup end=end_multi_hash_setup
```

### Defining a Sideloaded Proof

Usually, a `ZkProgram`'s proof type is inferrable, but since we want to sideload one of several proofs, we
need to define the proof class explicitly.

```ts file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_proof end=end_multi_hash_proof
```

### Using the Sideloaded Proof in a ZkProgram

Now that we've defined the proof class, we can use it in a `ZkProgram`.

```ts file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_program end=end_multi_hash_program
```

### Instantiation and Verifying the Wrap Proof