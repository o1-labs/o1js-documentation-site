```ts
function Option<A>(type: A): ProvableInferPureFrom<A, Option<InferProvable<A>, InferValue<A>>, InferValue<A> | undefined> & (option: {
  isSome: Bool;
  value: InferProvable<A>;
 }) => Option<InferProvable<A>, InferValue<A>> & {
  from: Option<InferProvable<A>, InferValue<A>>;
  fromValue: Option<InferProvable<A>, InferValue<A>>;
  none: Option<InferProvable<A>, InferValue<A>>;
}
```

Defined in: [lib/provable/option.ts:34](https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/provable/option.ts#L34)

Define an optional version of a provable type.

## Type Parameters

â€¢ **A** *extends* [`ProvableType`](../type-aliases/ProvableType.mdx)

## Parameters

### type

`A`

## Returns

`ProvableInferPureFrom`\<`A`, [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>, `InferValue`\<`A`\> \| `undefined`\> & (`option`: \{
  `isSome`: [`Bool`](../type-aliases/Bool.mdx);
  `value`: [`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>;
 \}) => [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\> & \{
  `from`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
  `fromValue`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
  `none`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
 \}

## Example

```ts
class OptionUInt64 extends Option(UInt64) {}

// create an optional UInt64
let some = OptionUInt64.from(5n);
let none = OptionUInt64.none();

// get back a UInt64
let five: UInt64 = some.assertSome('must have a value');
let zero: UInt64 = none.orElse(0n); // specify a default value
```
