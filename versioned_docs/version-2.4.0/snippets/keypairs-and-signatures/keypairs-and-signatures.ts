import {
  createEcdsa,
  PublicKey,
  PrivateKey,
  Signature,
  CircuitString,
  createForeignCurve,
  Crypto,
  Bytes,
} from "o1js";

// start_native_signature
const privateKey = PrivateKey.random();
const publicKey = privateKey.toPublicKey();
const message = CircuitString.fromString("Hello World!").values.map((char) =>
  char.toField()
);
const signature = Signature.create(privateKey, message);
signature.verify(publicKey, message);
// end_native_signature

// start_ethereum_signature
class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
class Ecdsa extends createEcdsa(Secp256k1) {}
class Bytes32 extends Bytes(32) {}

const messageEth = "Secrets hidden, truth in ZKPs ;)";

// compressed public key generated by ethers.js
const publicKeyEth = Secp256k1.fromEthers(
  "0x020957928494c38660d254dc03ba78f091a4aea0270afb447f193c4daf6648f02b"
);

// ECDSA signature generated by ethers.js
const signatureEth = Ecdsa.fromHex(
  "0x6fada464c3bc2ae127f8c907c0c4bccbd05ba83a584156edb808b7400346b4c9558598d9c7869f5fd75d81128711f6621e4cb5ba2f52a2a51c46c859f49a833a1b"
);
const msgBytes = Bytes32.fromString(messageEth);

signatureEth.verifyEthers(msgBytes, publicKeyEth);
// end_ethereum_signature

export {
  privateKey,
  publicKey,
  message,
  signature,
  messageEth,
  publicKeyEth,
  msgBytes,
  signatureEth,
};
