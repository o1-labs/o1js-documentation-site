"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[12965],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var o=t(96540);const i={},s=o.createContext(i);function r(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),o.createElement(s.Provider,{value:e},n.children)}},76181:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"advanced-concepts/recursion","title":"Recursive Zk Proofs","description":"Recursion is a powerful tool for solving complex problems with zk proofs.  Any particular constraint system will be limited by","source":"@site/docs/advanced-concepts/recursion.mdx","sourceDirName":"advanced-concepts","slug":"/advanced-concepts/recursion","permalink":"/documentation-site/advanced-concepts/recursion","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/advanced-concepts/recursion.mdx","tags":[],"version":"current","frontMatter":{"title":"Recursive Zk Proofs","sidebar_label":"Recursion"},"sidebar":"docs","previous":{"title":"Serialization","permalink":"/documentation-site/advanced-concepts/serialization"},"next":{"title":"Sideloading","permalink":"/documentation-site/advanced-concepts/sideloaded-vks"}}');var i=t(74848),s=t(28453);const r={title:"Recursive Zk Proofs",sidebar_label:"Recursion"},a=void 0,c={},l=[{value:"Fibonacci Example",id:"fibonacci-example",level:2},{value:"Compressing a Queue example",id:"compressing-a-queue-example",level:2},{value:"Verifying Zk Proofs of Different Shapes",id:"verifying-zk-proofs-of-different-shapes",level:2}];function p(n){const e={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"Recursion is a powerful tool for solving complex problems with zk proofs.  Any particular constraint system will be limited by\nthe lack of dynamic programming and conditional execution, but these shortcomings can be mitigated at the system architecture\nlevel with recursion."}),"\n",(0,i.jsx)(e.h2,{id:"fibonacci-example",children:"Fibonacci Example"}),"\n",(0,i.jsx)(e.p,{children:"The Fibonacci sequence is a classic example of recursion.  We can use recursive zk proofs to succinctly verify any element in\nthe sequence."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_fibonacci end=end_fibonacci",children:'class FibonacciState extends Struct({\n  index: UInt32,\n  n_1: UInt32,\n  n_2: UInt32,\n}) {\n  static empty() {\n    return new FibonacciState({\n      index: UInt32.zero,\n      n_1: UInt32.zero,\n      n_2: UInt32.zero,\n    });\n  }\n  assertEquals(other: FibonacciState) {\n    this.index.assertEquals(other.index);\n    this.n_1.assertEquals(other.n_1);\n    this.n_2.assertEquals(other.n_2);\n  }\n}\n\nconst Fibonacci = ZkProgram({\n  name: "Fibonacci",\n  publicInput: FibonacciState,\n  publicOutput: FibonacciState,\n\n  methods: {\n    base: {\n      privateInputs: [],\n      method: async (_: FibonacciState) => {\n        return {\n          publicOutput: new FibonacciState({\n            index: UInt32.from(1),\n            n_1: UInt32.from(1),\n            n_2: UInt32.from(1),\n          }),\n        };\n      },\n    },\n    recursive: {\n      privateInputs: [SelfProof],\n      method: async (\n        input: FibonacciState,\n        // Note that the `SelfProof` syntax here means that the proof has public input: FibonacciState and public output: FibonacciState\n        previousProof: SelfProof<FibonacciState, FibonacciState>\n      ) => {\n        // Assert that the public input to this method matches the public output of the previous proof\n        input.assertEquals(previousProof.publicOutput);\n        // Verify the previous proof\n        previousProof.verify();\n\n        // Return the next Fibonacci number\n        return {\n          publicOutput: new FibonacciState({\n            index: input.index.add(1),\n            n_1: input.n_1.add(input.n_2),\n            n_2: input.n_1,\n          }),\n        };\n      },\n    },\n  },\n});\n\n// Usage\nawait Fibonacci.compile();\nconst proof1 = await Fibonacci.base(FibonacciState.empty());\nconst proof2 = await Fibonacci.recursive(\n  proof1.proof.publicOutput,\n  proof1.proof\n);\nconst proof3 = await Fibonacci.recursive(\n  proof2.proof.publicOutput,\n  proof2.proof\n);\nconst proof4 = await Fibonacci.recursive(\n  proof3.proof.publicOutput,\n  proof3.proof\n);\nconst proof5 = await Fibonacci.recursive(\n  proof4.proof.publicOutput,\n  proof4.proof\n);\n'})}),"\n",(0,i.jsx)(e.h2,{id:"compressing-a-queue-example",children:"Compressing a Queue example"}),"\n",(0,i.jsx)(e.p,{children:"A good use case for ZK, in general, is the ability to compress a computation of several steps into a single proof that all steps\nwere executed, with a specific outcome.  Since a single proof can't accept a dynamicly sized input, we can use recursion to\nprocess fixed-size batches of inputs, and combine the results into one succinct proof.  In this example, we add over a queue\nof numbers to prove the sum."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_compress end=end_compress",children:'// Example, generate list of blocks that should be compressed\nlet lastHash = Poseidon.hash([UInt32.zero.value]);\nconst blocks = [{ value: UInt32.zero, hash: lastHash }];\nfor (let i = 0; i < 3; i++) {\n  const value = UInt32.from(Math.floor(Math.random() * 100));\n  const block = { value, hash: Poseidon.hash([lastHash, value.value]) };\n  blocks.push(block);\n  lastHash = block.hash;\n}\n\nclass BlockProofOutputs extends Struct({\n  currentSum: UInt32,\n  startingHash: Field,\n  endingHash: Field,\n}) {}\n\nconst SumBlocks = ZkProgram({\n  name: "SumBlocks",\n  publicInput: UInt32,\n  publicOutput: BlockProofOutputs,\n\n  methods: {\n    base: {\n      privateInputs: [],\n      method: async (_: UInt32) => {\n        return {\n          publicOutput: new BlockProofOutputs({\n            currentSum: UInt32.zero,\n            startingHash: Poseidon.hash([UInt32.zero.value]),\n            endingHash: Poseidon.hash([UInt32.zero.value]),\n          }),\n        };\n      },\n    },\n    addNext: {\n      privateInputs: [SelfProof],\n      method: async (\n        input: UInt32,\n        previousProof: SelfProof<UInt32, BlockProofOutputs>\n      ) => {\n        previousProof.verify();\n\n        return {\n          publicOutput: new BlockProofOutputs({\n            currentSum: previousProof.publicOutput.currentSum.add(input),\n            startingHash: previousProof.publicOutput.startingHash,\n            endingHash: Poseidon.hash([\n              previousProof.publicOutput.endingHash,\n              input.value,\n            ]),\n          }),\n        };\n      },\n    },\n  },\n});\n\n// Usage\nawait SumBlocks.compile();\n\nconst baseProof = await SumBlocks.base(UInt32.zero);\nlet proof = baseProof;\nfor (let i = 1; i < blocks.length; i++) {\n  const block = blocks[i];\n  const nextProof = await SumBlocks.addNext(block.value, proof.proof);\n  proof = nextProof;\n}\n\n'})}),"\n",(0,i.jsx)(e.h2,{id:"verifying-zk-proofs-of-different-shapes",children:"Verifying Zk Proofs of Different Shapes"}),"\n",(0,i.jsxs)(e.p,{children:["Recursive zk proofs can be used to verify ",(0,i.jsx)(e.em,{children:"any"})," other proof written in o1js.  It doesn't have to be limited to a program that\ndoes one reptetitive task several times.  Although a single constraint system can't have branching logic, you can branch\nat a system level by using proofs that verify other proofs. In this example we handle inputs differently based on the color\nproperty on the input."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_branch end=end_branch",children:'// Example, generate list of public keys that are allowed to use a system\nconst approvedUsers = Array.from({ length: 5 }, () => PrivateKey.random());\nclass MyMerkleMap extends Experimental.IndexedMerkleMap(4) {}\nconst approvedUsersMap = new MyMerkleMap();\nfor (let i = 0; i < approvedUsers.length; i++) {\n  approvedUsersMap.set(\n    BigInt(i),\n    Poseidon.hash(approvedUsers[i].toPublicKey().toFields())\n  );\n}\n\nconst Eligibility = ZkProgram({\n  name: "Eligibility",\n  publicOutput: null,\n\n  methods: {\n    check: {\n      privateInputs: [Field, PrivateKey],\n      method: async (index: Field, key: PrivateKey) => {\n        approvedUsersMap\n          .get(index)\n          .assertEquals(Poseidon.hash(key.toPublicKey().toFields()));\n      },\n    },\n  },\n});\n\n// Define the proof class of the eligibility program\nclass EligibilityProof extends ZkProgram.Proof(Eligibility) {}\n\nconst ExampleApplication = ZkProgram({\n  name: "ExampleApplication",\n  publicInput: null,\n  publicOutput: null,\n  methods: {\n    use: {\n      privateInputs: [EligibilityProof],\n      method: async (eligibilityProof: EligibilityProof) => {\n        // Verify the eligibility proof\n        eligibilityProof.verify();\n\n        // We now know that the user is eligible to use the system\n        // This is comparable to `if( user in approvedUsers ) { ... }` but accounting for the lack of conditional execution in zk programs\n        // Do something with the user\n        // ...\n\n        Field(0).assertEquals(0);\n      },\n    },\n  },\n});\n// Usage\nconst e = await Eligibility.compile();\nawait ExampleApplication.compile();\n\nconst eligibilityProof = await Eligibility.check(Field(0), approvedUsers[0]);\n// We can use the proof of eligibility from one program as an input to another program\nconst exampleProof = await ExampleApplication.use(eligibilityProof.proof);\n'})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}}}]);