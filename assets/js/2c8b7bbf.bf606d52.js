"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[8135],{2160:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/field","title":"Field","description":"Field","source":"@site/docs/getting-started/field.mdx","sourceDirName":"getting-started","slug":"/getting-started/field","permalink":"/documentation-site/getting-started/field","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/getting-started/field.mdx","tags":[],"version":"current","frontMatter":{"title":"Field"},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/documentation-site/"},"next":{"title":"Built-in Types","permalink":"/documentation-site/getting-started/built-in-types"}}');var s=n(4848),r=n(8453);n(8069);const a=JSON.parse('{"X":"28948022309329048855892746252171976963363056481941560715954676764349967630337"}'),d={title:"Field"},l=void 0,o={},c=[{value:"Field",id:"field",level:2},{value:"Overflow Behavior",id:"overflow-behavior",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"field",children:"Field"}),"\n",(0,s.jsx)(t.p,{children:"Field elements are the basic unit of data in zero knowledge proof programming.  An element of a Field is like an integer, except that all operations\nare perfomed modulo a prime.  Each field element can store a number up to almost 256 bits in size.  All other data types that can be used in\nprovable code can be represented as Fields."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["For the cryptography inclined, the exact max value that a field can store is: ",BigInt(a.X).toLocaleString(),"."]})}),"\n",(0,s.jsx)(t.p,{children:"For example, in typical programming, you might use:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"const sum = 1 + 3;"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"In o1js, you write this as:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_sum_1 end=end_sum_1",children:"const sum1 = new Field(1).add(new Field(3));\n"})}),"\n",(0,s.jsx)(t.p,{children:"This can be simplified as:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_sum_2 end=end_sum_2",children:"// Note that the `3` is automatically converted to a Field instance.\nconst sum2 = new Field(1).add(3);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"overflow-behavior",children:"Overflow Behavior"}),"\n",(0,s.jsxs)(t.p,{children:["Field arithmetic supports overflow and underflow.  See ",(0,s.jsx)(t.a,{href:"/documentation-site/getting-started/built-in-types#integers",children:"Integers"})," for an o1js type that behaves more like a traditional integer type."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_overflow end=end_overflow",children:"// The result is 0 because the sum overflows.\nconst overflow = new Field(Field.ORDER).add(1);\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_underflow end=end_underflow",children:"// The result is equivalent to the order of the field because the subtraction underflows.\nconst underflow = new Field(0).sub(1);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Read more at the ",(0,s.jsx)(t.a,{href:"/documentation-site/api-reference/classes/Field",children:"language reference"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);