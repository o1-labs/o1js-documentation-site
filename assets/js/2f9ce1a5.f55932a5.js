"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[5479],{8208:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"api-reference/type-aliases/ZkappPublicInput","title":"ZkappPublicInput","description":"Defined in1916","source":"@site/docs/api-reference/type-aliases/ZkappPublicInput.md","sourceDirName":"api-reference/type-aliases","slug":"/api-reference/type-aliases/ZkappPublicInput","permalink":"/documentation-site/api-reference/type-aliases/ZkappPublicInput","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/type-aliases/ZkappPublicInput.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ZkProgram","permalink":"/documentation-site/api-reference/type-aliases/ZkProgram"},"next":{"title":"Account","permalink":"/documentation-site/api-reference/variables/Account"}}');var i=n(4848),c=n(8453);const s={},r=void 0,o={},p=[{value:"Type declaration",id:"type-declaration",level:2},{value:"accountUpdate",id:"accountupdate",level:3},{value:"calls",id:"calls",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"type ZkappPublicInput = {\n  accountUpdate: Field;\n  calls: Field;\n};\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Defined in: ",(0,i.jsx)(t.a,{href:"https://github.com/o1-labs/o1js/blob/89b7d1522af805d6d4c45a96d7a9cbc29a457aec/src/lib/mina/v1/account-update.ts#L1916",children:"lib/mina/v1/account-update.ts:1916"})]}),"\n",(0,i.jsx)(t.p,{children:"The public input for zkApps consists of certain hashes of the proving\naccount update (and its child updates) which is constructed during method execution."}),"\n",(0,i.jsx)(t.p,{children:"For SmartContract proving, a method is run twice: First outside the proof, to\nobtain the public input, and once in the prover, which takes the public input\nas input. The current transaction is hashed again inside the prover, which\nasserts that the result equals the input public input, as part of the snark\ncircuit. The block producer will also hash the transaction they receive and\npass it as a public input to the verifier. Thus, the transaction is fully\nconstrained by the proof - the proof couldn't be used to attest to a different\ntransaction."}),"\n",(0,i.jsx)(t.h2,{id:"type-declaration",children:"Type declaration"}),"\n",(0,i.jsx)(t.h3,{id:"accountupdate",children:"accountUpdate"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"accountUpdate: Field;\n"})}),"\n",(0,i.jsx)(t.h3,{id:"calls",children:"calls"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"calls: Field;\n"})})]})}function u(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(6540);const i={},c=a.createContext(i);function s(e){const t=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(c.Provider,{value:t},e.children)}}}]);