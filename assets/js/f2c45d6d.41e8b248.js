"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[1391],{1179:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"basic-types/field","title":"Field","description":"Field","source":"@site/docs/basic-types/field.mdx","sourceDirName":"basic-types","slug":"/basic-types/field","permalink":"/documentation-site/basic-types/field","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/basic-types/field.mdx","tags":[],"version":"current","frontMatter":{"title":"Field"},"sidebar":"docs","previous":{"title":"What is a ZK Contraint System?","permalink":"/documentation-site/getting-started/what-is-a-zk-constraint-system"},"next":{"title":"Integers","permalink":"/documentation-site/basic-types/int"}}');var n=s(4848),a=s(8453);s(8069);const r=JSON.parse('{"X":"28948022309329048855892746252171976963363056481941560715954676764349967630337"}'),l={title:"Field"},d=void 0,o={},c=[{value:"Field",id:"field",level:2},{value:"Overflow Behavior",id:"overflow-behavior",level:3}];function p(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"field",children:"Field"}),"\n",(0,n.jsx)(t.p,{children:"Field elements are the basic unit of data in zero knowledge proof programming.  An element of a Field is like an integer, except that all operations\nare perfomed modulo a prime.  Each field element can store a number up to almost 256 bits in size.  All other data types that can be used in\nprovable code can be represented as Fields."}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["For the cryptography inclined, the exact max value that a field can store is: ",BigInt(r.X).toLocaleString(),"."]})}),"\n",(0,n.jsx)(t.p,{children:"For example, in typical programming, you might use:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"const sum = 1 + 3;"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In o1js, you write this as:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_sum_1 end=end_sum_1",children:"const sum1 = new Field(1).add(new Field(3));\n"})}),"\n",(0,n.jsx)(t.p,{children:"This can be simplified as:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_sum_2 end=end_sum_2",children:"// Note that the `3` is automatically converted to a Field instance.\nconst sum2 = new Field(1).add(3);\n"})}),"\n",(0,n.jsx)(t.h3,{id:"overflow-behavior",children:"Overflow Behavior"}),"\n",(0,n.jsxs)(t.p,{children:["Field arithmetic supports overflow and underflow.  See ",(0,n.jsx)(t.a,{href:"/docs/getting-started/built-in-types.mdx#integers",children:"Integers"})," for an o1js type that behaves more like a traditional integer type."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_overflow end=end_overflow",children:"// The result is 0 because the sum overflows.\nconst overflow = new Field(Field.ORDER - 1n).add(1);\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/field/field.ts start=start_underflow end=end_underflow",children:"// The result is equivalent to the order of the field minus 1 because the subtraction underflows.\nconst underflow = new Field(0).sub(1);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Read more at the language reference: ",(0,n.jsx)(t.a,{href:"/documentation-site/api-reference/classes/Field",children:"Field"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}}}]);