"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[38561],{22806:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"advanced-concepts/sideloaded-vks","title":"Sideloaded Verification Keys","description":"In the article on recursion, we showed how o1js can be used to","source":"@site/docs/advanced-concepts/sideloaded-vks.mdx","sourceDirName":"advanced-concepts","slug":"/advanced-concepts/sideloaded-vks","permalink":"/documentation-site/advanced-concepts/sideloaded-vks","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/advanced-concepts/sideloaded-vks.mdx","tags":[],"version":"current","frontMatter":{"title":"Sideloaded Verification Keys","sidebar_label":"Sideloading"},"sidebar":"docs","previous":{"title":"Recursion","permalink":"/documentation-site/advanced-concepts/recursion"},"next":{"title":"o1js API Reference","permalink":"/documentation-site/api-reference/Introduction"}}');var s=a(74848),i=a(28453);const o={title:"Sideloaded Verification Keys",sidebar_label:"Sideloading"},r=void 0,l={},d=[{value:"Multiple Hash Example",id:"multiple-hash-example",level:2},{value:"Setup",id:"setup",level:3},{value:"Defining a Sideloaded Proof",id:"defining-a-sideloaded-proof",level:3},{value:"Using the Sideloaded Proof in a ZkProgram",id:"using-the-sideloaded-proof-in-a-zkprogram",level:3},{value:"Instantiation and Verifying the Wrap Proof",id:"instantiation-and-verifying-the-wrap-proof",level:3}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In the article on ",(0,s.jsx)(t.a,{href:"/documentation-site/advanced-concepts/recursion",children:"recursion"}),", we showed how o1js can be used to\nwrite constraint systems that verify other constraint systems.  Those examples always assumed that the\nprover has compiled an instance of the other ",(0,s.jsx)(t.code,{children:"ZkProgram"}),".  We can, in fact, go even more general than that.\nWith sideloading, we can verify any proof, given that its shape (public inputs and outputs) are known at\ncompile time, and the verification key is available at runtime."]}),"\n",(0,s.jsx)(t.h2,{id:"multiple-hash-example",children:"Multiple Hash Example"}),"\n",(0,s.jsx)(t.p,{children:"Let's say we have an application with multiple hashing algorithms in use.  We want to write a simple Zk\nProgram to verify that a user knows the preimage of a hash, but we want to support any of our\nalgorithms.  Let's solve this by writing a specific program for each algorithm, and a wrapper program\nthat verifies any of them."}),"\n",(0,s.jsx)(t.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(t.p,{children:"First, let's set up a bytes32 class and some different hash function proofs.  Note that all proofs must\nhave the same shape."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_setup end=end_multi_hash_setup",children:'// Define our bytes input\nclass Bytes32 extends Bytes(32) {\n  static assertEquals(a: Bytes, b: Bytes) {\n    Poseidon.hash(a.toFields()).assertEquals(Poseidon.hash(b.toFields()));\n  }\n}\n\nconst Sha2 = ZkProgram({\n  name: "SHA2_256",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [Bytes32],\n      method: async (claimedHash: Bytes32, preimage: Bytes32) => {\n        const calculatedHash = Hash.SHA2_256.hash(preimage);\n        Bytes32.assertEquals(claimedHash, calculatedHash);\n      },\n    },\n  },\n});\n\nconst Sha3 = ZkProgram({\n  name: "SHA3_256",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [Bytes32],\n      method: async (claimedHash: Bytes32, preimage: Bytes32) => {\n        const calculatedHash = Hash.SHA3_256.hash(preimage);\n        Bytes32.assertEquals(claimedHash, calculatedHash);\n      },\n    },\n  },\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"defining-a-sideloaded-proof",children:"Defining a Sideloaded Proof"}),"\n",(0,s.jsxs)(t.p,{children:["Usually, a ",(0,s.jsx)(t.code,{children:"ZkProgram"}),"'s proof type is inferrable, but since we want to sideload one of several proofs, we\nneed to define the proof class explicitly."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_proof end=end_multi_hash_proof",children:"// Define the proof shape that both hash implementations satisfy\nclass HashProof extends DynamicProof<Bytes32, null> {\n  /**\n   * Bytes.provable is a little trick to access the provable type of the class - Not required for simpler types like Field or UInt32\n   */\n  static publicInputType = Bytes32.provable;\n  /**\n   * Hacky way to set the public output type to null\n   */\n  static publicOutputType = Sha2.publicOutputType;\n  /**\n   * maxProofsVerified sets the wrapping domain for this proof.\n   * Essentially, it tells the compiler how many times `verify` may be called\n   */\n  static maxProofsVerified = 0 as const;\n  /**\n   * Set all feature flags to maybe to indicate that the sideloaded proof may use any gate types\n   * NOTE: Failing to do this may result in a nasty error - unless you sepcifically want to exclude a feature, allMaybe is a safe default\n   */\n  static featureFlags = FeatureFlags.allMaybe;\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"using-the-sideloaded-proof-in-a-zkprogram",children:"Using the Sideloaded Proof in a ZkProgram"}),"\n",(0,s.jsxs)(t.p,{children:["Now that we've defined the proof class, we can use it in a ",(0,s.jsx)(t.code,{children:"ZkProgram"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_program end=end_multi_hash_program",children:'// Define our generic multi-hash program\nconst MultiHash = ZkProgram({\n  name: "MultiHash",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [HashProof, VerificationKey],\n      method: async (\n        claimedHash: Bytes32,\n        proof: HashProof,\n        verificationKey: VerificationKey\n      ) => {\n        // Pass verification key into `proof.verify` in the sideloaded case\n        proof.verify(verificationKey);\n\n        // Assert that the verification key matches one of our known programs\n        // NOTE: A merkle map could be a more efficient check for larger sets\n        // but this example uses a simpler check for clarity\n        let match = Bool(false);\n        match = match.or(\n          // SHA2_256 VK\n          verificationKey.hash.equals(\n            "18946629726997484436154648354739477208964589603707310554296950898554384176434"\n          )\n        );\n        match = match.or(\n          // SHA3_256 VK\n          verificationKey.hash.equals(\n            "10594931916390393299319985652348439891528773201960631586652037259274667432468"\n          )\n        );\n        match.assertEquals(true, "Invalid verification key");\n\n        // Now we know that the proof is legitimate\n        // The user provided proof that they know the preimage of _some_ hash\n        // Finally, let\'s confirm that _some_ hash is the hash being claimed\n        Bytes32.assertEquals(proof.publicInput, claimedHash);\n      },\n    },\n  },\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"instantiation-and-verifying-the-wrap-proof",children:"Instantiation and Verifying the Wrap Proof"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var n=a(96540);const s={},i=n.createContext(s);function o(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);