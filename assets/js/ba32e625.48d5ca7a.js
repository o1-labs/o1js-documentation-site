"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[533],{5676:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"writing-constraint-systems/conditional-logic","title":"Conditional Logic in Constraint Systems","description":"In provable code, we can\'t use the JavaScript if statement.  For a constraint system to be valid, it must follow the exact","source":"@site/docs/writing-constraint-systems/conditional-logic.mdx","sourceDirName":"writing-constraint-systems","slug":"/writing-constraint-systems/conditional-logic","permalink":"/documentation-site/writing-constraint-systems/conditional-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/writing-constraint-systems/conditional-logic.mdx","tags":[],"version":"current","frontMatter":{"title":"Conditional Logic in Constraint Systems"},"sidebar":"docs","previous":{"title":"Witnesses in Constraint Systems","permalink":"/documentation-site/writing-constraint-systems/witnesses"},"next":{"title":"Analyzing Constraint Systems","permalink":"/documentation-site/writing-constraint-systems/analyzing-constraint-systems"}}');var s=t(4848),a=t(8453);const o={title:"Conditional Logic in Constraint Systems"},l=void 0,d={},c=[{value:"Invalid Example",id:"invalid-example",level:2},{value:"Valid Example",id:"valid-example",level:2},{value:"Valid Example Using a Function",id:"valid-example-using-a-function",level:3}];function r(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["In provable code, we can't use the JavaScript ",(0,s.jsx)(n.code,{children:"if"})," statement.  For a constraint system to be valid, it must follow the exact\nsame path every time it's executed.  In traditional programming, what an ",(0,s.jsx)(n.code,{children:"if"})," statement does is evaluate an expression, then\njump to one of two different code paths.  This behavior can't be copied, but what ",(0,s.jsx)(n.em,{children:"is"})," possible within provable codes is\nsetting a variable based on the outcome of an expression.  The trick is that both sides of the expression will always be\nevaluated."]}),"\n",(0,s.jsx)(n.h2,{id:"invalid-example",children:"Invalid Example"}),"\n",(0,s.jsxs)(n.p,{children:["For a simple example of the kind of conditional logic that ",(0,s.jsx)(n.em,{children:"won't work"}),", see:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../../snippets/conditional-logic/conditional-logic.ts start=start_invalid_execution end=end_invalid_execution",children:"// INVALID - DO NOT COPY\nlet n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = Field.random();\n  Provable.if(\n    x.isEven(),\n    (n_heads = n_heads.add(1)),\n    (n_heads = n_heads.add(0))\n  );\n}\n// n_heads is ALWAYS 5\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The reason this code is invalid is that every iteration, we evaluate the true side, then the false side.  So we always\nadd ",(0,s.jsx)(n.code,{children:"1"}),", then ",(0,s.jsx)(n.code,{children:"0"})," to the number of heads flipped.  The result will always evaluate to the number of flips."]}),"\n",(0,s.jsx)(n.h2,{id:"valid-example",children:"Valid Example"}),"\n",(0,s.jsx)(n.p,{children:"Instead, write conditional logic like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../../snippets/conditional-logic/conditional-logic.ts start=start_valid_execution end=end_valid_execution",children:"let n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = Field.random();\n  const flip = Provable.if(x.isEven(), Field(1), Field(0));\n  n_heads = n_heads.add(flip);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This code will work correctly because we assign the result of the expression to a variable, and there are no other\nside effects caused by evaluating both sides."}),"\n",(0,s.jsx)(n.h3,{id:"valid-example-using-a-function",children:"Valid Example Using a Function"}),"\n",(0,s.jsx)(n.p,{children:"It is valid to execute code in both sides of the condition, as long as you understand the implications!  In general, a function\nthat returns a value and has no side effects is good to use in this case."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../../snippets/conditional-logic/conditional-logic.ts start=start_2_valid_execution_with_function end=end_2_valid_execution_with_function",children:"function oneMoreThan(x: Field) {\n  return x.add(1);\n}\n\nlet n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = Field.random();\n  const new_n_heads = Provable.if(x.isEven(), oneMoreThan(n_heads), n_heads);\n  n_heads = new_n_heads;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);